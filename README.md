# Portfolio

개인 포트폴리오 웹사이트입니다.

## 주요 기능

- 반응형 디자인
- 다크 모드 지원
- 프로젝트 갤러리
- 블로그 기능
- 다국어 지원 (한국어, 영어)

## 기술 스택

- Next.js 14
- TypeScript
- Material-UI
- Tailwind CSS
- Vercel (배포)

## 최근 변경사항

### 2024-03-21
- 로그인 페이지 UI 개선
  - 로딩 상태 표시 추가
  - 에러 메시지 표시 개선
  - 사용자 경험 향상을 위한 UI/UX 개선
- 보안 강화
  - 대외비 보호를 위한 인증 시스템 적용
  - 세션 관리 기능 추가

### 2024-03-20
- 다크 모드 지원 추가
- 반응형 디자인 개선
- 프로젝트 갤러리 UI 개선

## 설치 및 실행

```bash
# 의존성 설치
npm install

# 개발 서버 실행
npm run dev

# 프로덕션 빌드
npm run build
```

## 라이센스

MIT

# 홍지혜 포트폴리오

## 1. 프로젝트 개요

이 가이드는 Next.js와 Material-UI를 사용하여 개발자 포트폴리오 웹사이트를 구축하는 방법을 설명합니다. 포트폴리오 웹사이트는 개발자의 기술력과 경험을 효과적으로 보여주는 중요한 도구입니다. 이 가이드에서는 현대적인 웹 개발 기술을 활용하여 반응형이고 사용자 친화적인 포트폴리오를 만드는 방법을 단계별로 설명합니다.

## 2. 기술 스택

이 프로젝트에서는 다음과 같은 최신 웹 기술을 사용합니다:

- **Next.js 13**: React 기반의 서버 사이드 렌더링 프레임워크로, 빠른 페이지 로딩과 SEO 최적화를 제공합니다. App Router를 사용하여 더 직관적인 라우팅과 레이아웃 관리를 구현할 수 있습니다.

- **Material-UI (MUI)**: Google의 Material Design을 기반으로 한 UI 컴포넌트 라이브러리입니다. 일관된 디자인 시스템과 다양한 커스터마이징 옵션을 제공하여 전문적인 UI를 쉽게 구현할 수 있습니다.

- **Tailwind CSS**: 유틸리티 기반의 CSS 프레임워크로, 빠른 스타일링과 반응형 디자인 구현이 가능합니다. MUI와 함께 사용하여 더 유연한 스타일링이 가능합니다.

- **TypeScript**: JavaScript의 타입 안전성을 제공하는 프로그래밍 언어입니다. 코드의 안정성과 유지보수성을 높여줍니다.

- **Inter**: Google Fonts에서 제공하는 현대적인 산세리프 폰트로, 가독성이 뛰어나고 다양한 언어를 지원합니다.

## 3. 프로젝트 구조

프로젝트는 다음과 같은 구조로 구성되어 있습니다:

```
portfolio/
├── app/                    # Next.js 13의 App Router 구조
│   ├── components/         # 재사용 가능한 UI 컴포넌트
│   │   └── Navbar.tsx     # 네비게이션 바 컴포넌트
│   ├── data/              # 정적 데이터 파일
│   │   └── projects.ts    # 프로젝트 정보 데이터
│   ├── layout.tsx         # 공통 레이아웃 컴포넌트
│   ├── page.tsx           # 홈페이지 컴포넌트
│   └── projects/          # 프로젝트 페이지 관련 파일
│       └── page.tsx       # 프로젝트 목록 페이지
├── public/                # 정적 파일 디렉토리
│   └── images/           # 이미지 파일
│       └── projects/     # 프로젝트 관련 이미지
├── docs/                 # 문서 파일
│   └── portfolio-development-guide.md  # 개발 가이드
└── package.json          # 프로젝트 설정 및 의존성 관리
```

이 구조는 Next.js 13의 App Router를 기반으로 하며, 각 디렉토리와 파일은 특정 기능을 담당합니다. 컴포넌트는 재사용성을 고려하여 분리되어 있으며, 데이터는 별도의 파일로 관리됩니다.

## 4. 주요 컴포넌트 설명

### 4.1 Navbar 컴포넌트

Navbar 컴포넌트는 웹사이트의 상단에 위치하며, 사용자가 다른 페이지로 이동할 수 있는 네비게이션 링크를 제공합니다. 이 컴포넌트는 다음과 같은 특징을 가지고 있습니다:

- **반응형 디자인**: 화면 크기에 따라 자동으로 레이아웃이 변경됩니다. 데스크톱에서는 가로로 배치된 메뉴를, 모바일에서는 햄버거 메뉴를 표시합니다.
- **모바일 메뉴**: 작은 화면에서는 햄버거 메뉴를 클릭하면 슬라이드되는 드로어 메뉴가 나타납니다.
- **Material-UI 컴포넌트**: AppBar, Drawer, Button 등의 MUI 컴포넌트를 사용하여 일관된 디자인을 유지합니다.

### 4.2 홈페이지 (page.tsx)

홈페이지는 방문자에게 첫인상을 주는 중요한 페이지입니다. 다음과 같은 섹션들로 구성되어 있습니다:

- **자기소개 섹션**: 간단한 인사말과 함께 개발자로서의 정체성을 소개합니다.
- **기술 블로그 링크**: 개발 경험과 지식을 공유하는 블로그 링크를 제공합니다.
- **개발 철학**: 개발자로서의 가치관과 접근 방식을 설명합니다.
- **학력 및 경력**: 교육 배경과 직업 경력을 시간순으로 정리합니다.
- **기술 스택**: 주로 사용하는 프로그래밍 언어와 프레임워크를 카테고리별로 정리합니다.
- **논문 및 특허**: 연구 성과와 지적재산권을 소개합니다.

### 4.3 프로젝트 페이지 (projects/page.tsx)

프로젝트 페이지는 실제 작업한 프로젝트들을 보여주는 공간입니다:

- **프로젝트 카드 그리드**: 각 프로젝트를 카드 형태로 보여주며, 이미지, 제목, 간단한 설명을 포함합니다.
- **상세 정보 다이얼로그**: 카드를 클릭하면 프로젝트의 상세 정보가 모달 창으로 표시됩니다.
- **카테고리 필터링**: 프로젝트를 회사별, 기술별로 필터링할 수 있는 기능을 제공합니다.

## 5. 데이터 구조

프로젝트 데이터는 TypeScript 인터페이스를 사용하여 구조화되어 있습니다:

```typescript
interface Project {
  id: string;          // 프로젝트 고유 식별자
  title: string;       // 프로젝트 제목
  category: string;    // 프로젝트 카테고리 (회사명 등)
  period: string;      // 프로젝트 기간
  description: string; // 간단한 프로젝트 설명
  details: {
    overview: string;      // 상세한 프로젝트 개요
    goals: string[];       // 프로젝트 목표
    technologies: string[]; // 사용된 기술 스택
    achievements: string[]; // 달성한 성과
  };
}
```

이 데이터 구조는 프로젝트의 모든 정보를 체계적으로 관리할 수 있도록 설계되었습니다. 각 필드는 특정 정보를 담당하며, details 객체는 프로젝트의 상세 정보를 구조화된 형태로 저장합니다.

## 6. 스타일링 가이드

### 6.1 Material-UI 테마 설정

Material-UI의 테마 시스템을 활용하여 일관된 디자인을 구현합니다:

- **커스텀 테마 설정**: 프로젝트의 브랜드 아이덴티티에 맞는 색상, 타이포그래피, 간격 등을 정의합니다.
- **반응형 디자인**: 화면 크기에 따라 자동으로 조정되는 레이아웃을 구현합니다.
- **일관된 색상 팔레트**: 전체 웹사이트에서 일관된 색상 사용을 위해 테마 색상을 정의합니다.

### 6.2 반응형 디자인

모든 디자인은 모바일 퍼스트 접근법을 따릅니다:

- **모바일 퍼스트**: 작은 화면부터 시작하여 점진적으로 더 큰 화면에 맞게 확장합니다.
- **브레이크포인트**: Material-UI의 기본 브레이크포인트를 활용하여 반응형 레이아웃을 구현합니다.
- **유동적인 레이아웃**: Flexbox와 Grid를 활용하여 다양한 화면 크기에 대응합니다.

## 7. 배포 가이드

프로젝트 배포는 다음과 같은 단계로 진행됩니다:

1. **프로젝트 빌드**
   ```bash
   npm run build
   ```
   이 명령어는 프로젝트를 프로덕션 환경에 맞게 최적화하여 빌드합니다.

2. **정적 파일 생성**
   ```bash
   npm run export
   ```
   Next.js 프로젝트를 정적 파일로 내보내어 다양한 호스팅 서비스에 배포할 수 있습니다.

3. **호스팅 서비스 선택**
   - **Vercel**: Next.js를 개발한 팀이 만든 호스팅 서비스로, Next.js 프로젝트에 최적화되어 있습니다.
   - **Netlify**: 정적 사이트 호스팅에 특화된 서비스로, CI/CD 파이프라인을 제공합니다.
   - **GitHub Pages**: GitHub 저장소를 통해 무료로 정적 사이트를 호스팅할 수 있습니다.

## 8. 유지보수 가이드

### 8.1 프로젝트 업데이트

프로젝트를 지속적으로 업데이트하는 방법:

- **새로운 프로젝트 추가**: projects.ts 파일에 새로운 프로젝트 정보를 추가하고, 필요한 이미지를 public/images/projects 디렉토리에 추가합니다.
- **기술 스택 업데이트**: 새로운 기술을 습득하면 기술 스택 섹션을 업데이트합니다.
- **경력 정보 갱신**: 새로운 경력이나 업적이 있으면 관련 섹션을 수정합니다.

### 8.2 성능 최적화

웹사이트의 성능을 최적화하는 방법:

- **이미지 최적화**: Next.js의 Image 컴포넌트를 사용하여 이미지를 최적화합니다.
- **코드 스플리팅**: 페이지별로 코드를 분리하여 초기 로딩 시간을 단축합니다.
- **캐싱 전략**: 정적 자원에 적절한 캐싱 헤더를 설정하여 성능을 향상시킵니다.

## 9. 보안 고려사항

웹사이트의 보안을 유지하기 위한 방법:

- **API 키 관리**: 환경 변수를 사용하여 API 키를 안전하게 관리합니다.
- **민감한 정보 보호**: 개인 정보나 민감한 데이터는 절대 클라이언트 사이드에 노출하지 않습니다.
- **HTTPS 사용**: 모든 통신을 HTTPS로 암호화하여 보안을 강화합니다.

## 10. 참고 자료

프로젝트 개발에 도움이 되는 공식 문서:

- [Next.js 공식 문서](https://nextjs.org/docs): Next.js의 모든 기능과 사용법을 상세히 설명합니다.
- [Material-UI 공식 문서](https://mui.com/): MUI 컴포넌트의 사용법과 커스터마이징 방법을 제공합니다.
- [Tailwind CSS 공식 문서](https://tailwindcss.com/docs): Tailwind CSS의 유틸리티 클래스와 사용법을 설명합니다.

## 11. 일반적인 오류 및 해결 방법

### 11.1 Next.js 관련 오류

#### 11.1.1 Hydration 오류

Hydration 오류는 서버 사이드 렌더링과 클라이언트 사이드 렌더링 간의 불일치로 발생합니다. 이는 주로 동적 데이터나 브라우저 API를 사용할 때 발생합니다.

**해결 방법**:
1. `useEffect` 훅을 사용하여 클라이언트 사이드에서만 실행되도록 설정합니다. 이는 컴포넌트가 마운트된 후에만 코드가 실행되도록 보장합니다.
2. 컴포넌트 상단에 `'use client'` 지시문을 추가하여 해당 컴포넌트가 클라이언트 사이드에서만 렌더링되도록 합니다.
3. 동적 데이터는 클라이언트 사이드에서만 렌더링하도록 조건부 렌더링을 사용합니다.

#### 11.1.2 이미지 최적화 오류

Next.js의 기본 이미지 최적화 기능은 `next export`와 호환되지 않을 수 있습니다.

**해결 방법**:
1. `next.config.js` 파일에 다음과 같은 설정을 추가합니다:
```javascript
module.exports = {
  images: {
    unoptimized: true
  }
}
```
이 설정은 이미지 최적화를 비활성화하고, 대신 정적 이미지를 사용하도록 합니다.

### 11.2 Material-UI 관련 오류

#### 11.2.1 스타일 충돌

서버 사이드 렌더링과 클라이언트 사이드 렌더링 간의 스타일 불일치로 인해 발생합니다.

**해결 방법**:
1. `_document.tsx` 파일에 서버 사이드 렌더링 설정을 추가합니다. 이는 스타일이 서버와 클라이언트에서 일관되게 적용되도록 합니다.
2. Emotion 캐시를 설정하여 스타일 충돌을 방지합니다.
3. `createEmotionCache` 함수를 구현하여 스타일 캐싱을 관리합니다.

#### 11.2.2 테마 적용 오류

테마가 제대로 적용되지 않는 경우 발생합니다.

**해결 방법**:
1. `_app.tsx` 파일에 ThemeProvider를 추가하여 전체 앱에 테마를 적용합니다.
2. 커스텀 테마 설정을 확인하고 필요한 경우 수정합니다.
3. 스타일 컴포넌트의 테마 타입을 정의하여 타입 안전성을 보장합니다.

### 11.3 TypeScript 관련 오류

#### 11.3.1 타입 정의 오류

타입이 예상과 다르게 정의되어 있을 때 발생합니다.

**해결 방법**:
1. 인터페이스 정의를 확인하고 필요한 경우 수정합니다.
2. 타입 단언(type assertion)을 사용하여 타입을 명시적으로 지정합니다.
3. 제네릭 타입을 활용하여 더 유연한 타입 정의를 구현합니다.

#### 11.3.2 모듈 해석 오류

타입스크립트가 모듈이나 타입 정의를 찾지 못할 때 발생합니다.

**해결 방법**:
1. 필요한 `@types` 패키지를 설치합니다.
2. `tsconfig.json`의 경로 설정을 확인하고 필요한 경우 수정합니다.
3. 타입 선언 파일을 생성하여 모듈의 타입을 정의합니다.

### 11.4 배포 관련 오류

#### 11.4.1 빌드 실패

빌드 과정에서 오류가 발생하는 경우입니다.

**해결 방법**:
1. `package.json`의 스크립트를 확인하고 필요한 경우 수정합니다.
2. 의존성 충돌을 해결하기 위해 패키지 버전을 조정합니다.
3. 캐시를 삭제하고 다시 빌드를 시도합니다:
```bash
rm -rf .next
npm run build
```

#### 11.4.2 정적 파일 생성 오류

정적 파일 생성 과정에서 오류가 발생하는 경우입니다.

**해결 방법**:
1. 동적 라우팅을 확인하고 필요한 경우 수정합니다.
2. `getStaticProps`를 구현하여 정적 페이지 생성을 지원합니다.
3. `next.config.js`의 설정을 수정하여 정적 파일 생성을 최적화합니다.

### 11.5 성능 관련 오류

#### 11.5.1 메모리 누수

컴포넌트가 언마운트된 후에도 상태 업데이트가 시도될 때 발생합니다.

**해결 방법**:
1. `useEffect`의 클린업 함수를 구현하여 컴포넌트 언마운트 시 리소스를 정리합니다.
2. 이벤트 리스너를 제거하여 메모리 누수를 방지합니다.
3. 타이머를 정리하여 불필요한 상태 업데이트를 방지합니다.

#### 11.5.2 렌더링 성능 저하

훅의 순서가 변경되거나 불필요한 리렌더링이 발생할 때 발생합니다.

**해결 방법**:
1. 조건부 훅 사용을 제한하여 훅의 순서가 일정하게 유지되도록 합니다.
2. `useMemo`와 `useCallback`을 활용하여 불필요한 리렌더링을 방지합니다.
3. 컴포넌트를 분리하여 렌더링 범위를 최적화합니다.

### 11.6 디버깅 팁

#### 1. 개발자 도구 활용

- **React Developer Tools**: 컴포넌트 계층 구조와 상태를 시각적으로 확인할 수 있습니다.
- **Chrome DevTools**: 네트워크 요청, 성능 프로파일링, 콘솔 로그 등을 확인할 수 있습니다.
- **Network 탭**: API 요청과 응답을 모니터링하여 문제를 진단할 수 있습니다.

#### 2. 로깅 전략

- **에러 로깅**: `console.log` 대신 `console.error`를 사용하여 에러를 명확히 구분합니다.
- **구조화된 로깅**: 로그 메시지를 일관된 형식으로 작성하여 분석을 용이하게 합니다.
- **에러 바운더리**: React의 에러 바운더리를 사용하여 예상치 못한 에러를 처리합니다.

#### 3. 테스트 방법

- **단위 테스트**: 각 컴포넌트와 함수의 동작을 검증합니다.
- **스토리북**: 컴포넌트의 다양한 상태를 시각적으로 확인할 수 있습니다.
- **수동 테스트**: 주요 기능과 사용자 경험을 직접 테스트하여 문제를 발견합니다. 